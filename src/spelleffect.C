/*-------------------------------------------------------------------------*\
  <spelleffect.C> -- Spell Effect implementation file

  Date      Programmer  Description
  11/09/00  Dennis      Created.
\*-------------------------------------------------------------------------*/

#include "spelleffect.h"
#include "display.h"
#include "combat.h"
#include "game.h"

#define BTSPELLFLG_DAMAGE 0
#define BTSPELLFLG_KILLED 1
#define BTSPELLFLG_EXCLAMATION 2

BTEffectSource::BTEffectSource(unsigned int t, int w, int e)
 : type(t), who(w), effectID(e)
{
}

BTEffectSource::BTEffectSource()
 : type(BTEFFECTTYPE_MAGIC), who(BTTARGET_NOSINGER), effectID(BTEFFECTID_NONE)
{
}

void BTEffectSource::serialize(ObjectSerializer *s)
{
 s->add("type", &type);
 s->add("who", &who);
 s->add("effectID", &effectID);
}

BTBaseEffect::BTBaseEffect(int t, int x, const BTEffectSource &s)
 : type(t), expiration(x), expire(false), first(true), source(s)
{
}

int BTBaseEffect::apply(BTDisplay &d, BTCombat *combat, int g /*= BTTARGET_NONE*/, int trgt /*= BTTARGET_INDIVIDUAL*/)
{
 if (g != BTTARGET_NONE)
  return 0;
 else
  return maintain(d, combat);
}

int BTBaseEffect::maintain(BTDisplay &d, BTCombat *combat)
{
 return 0;
}

void BTBaseEffect::finish(BTDisplay &d, BTCombat *combat, int g /*= BTTARGET_NONE*/, int trgt /*= BTTARGET_INDIVIDUAL*/)
{
}

void BTBaseEffect::serialize(ObjectSerializer *s)
{
 s->add("type", &type);
 s->add("expiration", &expiration);
 s->add("expire", &expire);
 s->add("first", &first);
 s->add("source", &source);
}

bool BTBaseEffect::targets(int g, int who, bool exact /*= true*/)
{
 return false;
}

bool BTBaseEffect::targetsMonsters()
{
 return false;
}

void BTBaseEffect::move(int g, int who, int where)
{
 if ((g == BTTARGET_PARTY) && (who == source.who))
 {
  source.who = where;
 }
 else if ((g == BTTARGET_PARTY) && (who < where) && (where >= source.who) && (who < source.who))
 {
  source.who--;
 }
 else if ((g == BTTARGET_PARTY) && (who > where) && (where <= source.who) && (who > source.who))
 {
  source.who++;
 }
}

void BTBaseEffect::remove(BTCombat *combat, int g, int who)
{
}

bool BTBaseEffect::isExpired(BTGame *game)
{
 if (expire)
  return true;
 if (game->isExpired(expiration))
 {
  return true;
 }
 else if (source.who != BTTARGET_NOSINGER)
 {
  BTParty &party = game->getParty();
  if (!party[source.who]->isAlive())
   return true;
  else
   return false;
 }
 else
  return false;
}

BTTargetedEffect::BTTargetedEffect(int t, int x, const BTEffectSource &s, int g, int trgt)
 : BTBaseEffect(t, x, s), group(g), target(trgt)
{
}

void BTTargetedEffect::serialize(ObjectSerializer *s)
{
 s->add("group", &group);
 s->add("target", &target);
 BTBaseEffect::serialize(s);
}

bool BTTargetedEffect::targets(int g, int who, bool exact /*= true*/)
{
 if ((g == group) && (who == target))
  return true;
 else if (!exact)
 {
  if ((g == BTTARGET_ALLMONSTERS) && (group >= BTTARGET_MONSTER))
   return true;
  if ((g == group) && (target == BTTARGET_INDIVIDUAL))
   return true;
  if ((g == group) && (who == BTTARGET_INDIVIDUAL))
   return true;
 }
 return false;
}

bool BTTargetedEffect::targetsMonsters()
{
 return group >= BTTARGET_MONSTER;
}

void BTTargetedEffect::move(int g, int who, int where)
{
 if ((g == group) && (who == target))
 {
  target = where;
 }
 else if ((g == group) && (who < where) && (where >= target) && (who < target))
 {
  target--;
 }
 else if ((g == group) && (who > where) && (where <= target) && (who > target))
 {
  target++;
 }
 BTBaseEffect::move(g, who, where);
}

void BTTargetedEffect::remove(BTCombat *combat, int g, int who)
{
 if ((group == g) && (target != BTTARGET_INDIVIDUAL) && (target > who))
 {
  --target;
 }
 else if ((group > g) && (target == BTTARGET_INDIVIDUAL))
 {
  --group;
 }
}

BTResistedEffect::BTResistedEffect(int t, int x, const BTEffectSource &s, int g, int trgt)
 : BTTargetedEffect(t, x, s, g, trgt)
{
}

void BTResistedEffect::serialize(ObjectSerializer *s)
{
 s->add("resists", &resists, NULL);
 BTTargetedEffect::serialize(s);
}

bool BTResistedEffect::checkResists(BTCombat *combat, int g /*= BTTARGET_NONE*/, int trgt /*= BTTARGET_INDIVIDUAL*/)
{
 if (g == BTTARGET_NONE)
 {
  g = group;
  trgt = target;
 }
 BTGame *game = BTGame::getGame();
 BTFactory<BTMonster> &monList = game->getMonsterList();
 if (BTTARGET_ALLMONSTERS == g)
 {
  int total = 0;
  bool allResists = true;
  for (int i = 0; i < BTCOMBAT_MAXENCOUNTERS; ++i)
  {
   BTMonsterGroup *grp = combat->getMonsterGroup(i);
   if (NULL == grp)
    break;
   int resistance = monList[grp->monsterType].getMagicResistance();
   if (resistance > 0)
   {
    for (int k = 0; k < grp->individual.size(); ++k)
    {
     if (BTDice(1, 100).roll() <= resistance)
      resists.set(total + k);
     else
      allResists = false;
    }
   }
   else
    allResists = false;
   total += grp->individual.size();
  }
  if (allResists)
   return true;
 }
 else if (BTTARGET_PARTY == g)
 {
  BTParty &party = game->getParty();
  if (BTTARGET_INDIVIDUAL == trgt)
  {
   bool allResists = true;
   for (int i = 0; i < party.size(); ++i)
   {
    if (BTMONSTER_NONE != party[i]->monster)
    {
     if (BTDice(1, 100).roll() <= monList[party[i]->monster].getMagicResistance())
      resists.set(i);
     else
      allResists = false;
    }
    else
     allResists = false;
   }
   if (allResists)
    return true;
  }
  else
  {
   if (BTMONSTER_NONE != party[trgt]->monster)
   {
    if (BTDice(1, 100).roll() <= monList[party[trgt]->monster].getMagicResistance())
    {
     if ((group == BTTARGET_PARTY) && (BTTARGET_INDIVIDUAL == target))
      resists.set(trgt);
     else
      resists.set(0);
     return true;
    }
   }
  }
 }
 else if (g >= BTTARGET_MONSTER)
 {
  BTMonsterGroup *grp = combat->getMonsterGroup(g - BTTARGET_MONSTER);
  int resistance = monList[grp->monsterType].getMagicResistance();
  if (resistance > 0)
  {
   if (BTTARGET_INDIVIDUAL == trgt)
   {
    bool allResists = true;
    for (int i = 0; i < grp->individual.size(); ++i)
    {
     if (BTDice(1, 100).roll() <= resistance)
      resists.set(i);
     else
      allResists = false;
    }
    if (allResists)
     return true;
   }
   else if (BTDice(1, 100).roll() <= resistance)
   {
    resists.set(0);
    return true;
   }
  }
 }
 return false;
}

BTAttackEffect::BTAttackEffect(int t, int x, const BTEffectSource &s, int rng, int erng, int d, int g, int trgt, const BTDice &dam, int sts, const std::string& tOnly)
 : BTResistedEffect(t, x, s, g, trgt), range(rng), effectiveRange(erng), distance(d), damage(dam), status(sts), tagOnly(tOnly)
{
}

void BTAttackEffect::serialize(ObjectSerializer *s)
{
 s->add("range", &range);
 s->add("effectiveRange", &effectiveRange);
 s->add("distance", &distance);
 s->add("damage", &damage);
 s->add("status", &status);
 s->add("tagOnly", &tagOnly);
 BTResistedEffect::serialize(s);
}

int BTAttackEffect::apply(BTDisplay &d, BTCombat *combat, int g /*= BTTARGET_NONE*/, int trgt /*= BTTARGET_INDIVIDUAL*/)
{
 if (g != BTTARGET_NONE)
 {
  checkResists(combat, g, trgt);
  return 0;
 }
 else
 {
  if (checkResists(combat, group, target))
  {
   displayResists(d, combat);
   throw BTAllResistException();
  }
  return maintain(d, combat);
 }
}

int BTAttackEffect::maintain(BTDisplay &d, BTCombat *combat)
{
 int killed = 0;
 BTGame *game = BTGame::getGame();
 BTFactory<BTMonster> &monList = game->getMonsterList();
 if (BTTARGET_PARTY == group)
 {
  BTParty &party = game->getParty();
  if (distance > (range * (1 + effectiveRange)))
   return 0;
  if (BTTARGET_INDIVIDUAL == target)
  {
   killed += applyToGroup(d, &party);
  }
  else
  {
   if ((party[target]->isAlive()) && ((tagOnly.empty()) || (party[target]->hasTag(tagOnly))))
   {
    int activeNum = 0;
    std::string text = BTCombatant::specialAttack(party[target], damage, status, (distance > range), activeNum);
    killed += abs(activeNum);
    d.drawMessage(text.c_str(), game->getDelay());
   }
  }
 }
 else if (BTTARGET_ALLMONSTERS == group)
 {
  int resistOffset = 0;
  for (int i = 0; i < BTCOMBAT_MAXENCOUNTERS; ++i)
  {
   BTMonsterGroup *grp = combat->getMonsterGroup(i);
   if (NULL == grp)
    break;
   killed += applyToGroup(d, grp, resistOffset);
   resistOffset += grp->size();
  }
 }
 else if (group >= BTTARGET_MONSTER)
 {
  BTMonsterGroup *grp = combat->getMonsterGroup(group - BTTARGET_MONSTER);
  if (abs(grp->distance - distance) > (range * (1 + effectiveRange)))
   return 0;
  if (BTTARGET_INDIVIDUAL == target)
  {
   killed += applyToGroup(d, grp);
  }
  else
  {
   if ((grp->individual[target].isAlive()) && ((tagOnly.empty()) || (grp->individual[target].hasTag(tagOnly))))
   {
    int activeNum = 0;
    std::string text = BTCombatant::specialAttack(&(grp->individual[target]), damage, status, (abs(grp->distance - distance) > range), activeNum);
    killed += abs(activeNum);
    d.drawMessage(text.c_str(), game->getDelay());
   }
  }
 }
 if (BTTARGET_PARTY == group)
  d.drawStats();
 return killed;
}

int BTAttackEffect::applyToGroup(BTDisplay &d, BTCombatantCollection *grp, int resistOffset /*= 0*/)
{
 if (abs(grp->getDistance() - distance) > (range * (1 + effectiveRange)))
  return 0;
 BTGame *game = BTGame::getGame();
 int killed(0);
 for (int i = 0; i < grp->size(); ++i)
 {
  bool saved = resists.isSet(resistOffset + i);
  int activeNum = 0;
  if ((grp->at(i)->isAlive()) && ((first) || (!saved)) && ((tagOnly.empty()) || (grp->at(i)->hasTag(tagOnly))))
  {
   std::string text = BTCombatant::specialAttack(grp->at(i), damage, status, (abs(grp->getDistance() - distance) > range), activeNum, (first ? &saved : NULL));
   killed += abs(activeNum);
   d.drawMessage(text.c_str(), game->getDelay());
  }
 }
 return killed;
}

void BTAttackEffect::finish(BTDisplay &d, BTCombat *combat, int g /*= BTTARGET_NONE*/, int trgt /*= BTTARGET_INDIVIDUAL*/)
{
 if (g == BTTARGET_NONE)
  return;
 if ((status == BTSTATUS_NONE) || (status == BTSTATUS_LEVELDRAIN) || (status == BTSTATUS_AGED))
  return;
 if (BTTARGET_PARTY == group)
 {
  BTGame *game = BTGame::getGame();
  BTParty &party = game->getParty();
  if (BTTARGET_INDIVIDUAL == target)
  {
   for (int i = 0; i < party.size(); ++i)
   {
    if ((party[i]->status.isSet(status)) && ((tagOnly.empty()) || (party[i]->hasTag(tagOnly))))
    {
     party[i]->status.clear(status);
    }
   }
  }
  else
  {
   if ((party[target]->status.isSet(status)) && ((tagOnly.empty()) || (party[target]->hasTag(tagOnly))))
   {
    party[target]->status.clear(status);
   }
  }
 }
 else if (BTTARGET_ALLMONSTERS == group)
 {
  for (int i = 0; i < BTCOMBAT_MAXENCOUNTERS; ++i)
  {
   BTMonsterGroup *grp = combat->getMonsterGroup(i);
   if (NULL == grp)
    break;
   for (int k = 0; k < grp->individual.size(); ++k)
   {
    if ((grp->individual[k].isAlive()) && (!grp->individual[k].status.isSet(status)) && ((tagOnly.empty()) || (grp->individual[k].hasTag(tagOnly))))
    {
     grp->individual[k].status.clear(status);
    }
   }
  }
 }
 else if (group >= BTTARGET_MONSTER)
 {
  BTMonsterGroup *grp = combat->getMonsterGroup(group - BTTARGET_MONSTER);
  if (BTTARGET_INDIVIDUAL == target)
  {
   for (int i = 0; i < grp->individual.size(); ++i)
   {
    if ((grp->individual[i].status.isSet(status)) && ((tagOnly.empty()) || (grp->individual[i].hasTag(tagOnly))))
    {
     grp->individual[i].status.clear(status);
    }
   }
  }
  else
  {
   if ((grp->individual[target].status.isSet(status)) && ((tagOnly.empty()) || (grp->individual[target].hasTag(tagOnly))))
   {
    grp->individual[target].status.clear(status);
   }
  }
 }
 if (BTTARGET_PARTY == group)
  d.drawStats();
}

void BTAttackEffect::move(int g, int who, int where)
{
 if ((g == group) && (BTTARGET_INDIVIDUAL == target))
 {
  resists.move(who, where);
 }
 BTTargetedEffect::move(g, who, where);
}

void BTAttackEffect::remove(BTCombat *combat, int g, int who)
{
 if ((group == g) && (target == BTTARGET_INDIVIDUAL))
 {
  resists.remove(who);
 }
 else if (group == BTTARGET_ALLMONSTERS)
 {
  int total = 0;
  for (int i = 0; i < g; ++i)
  {
   BTMonsterGroup *grp = combat->getMonsterGroup(i);
   if (NULL == grp)
    break;
   total += grp->individual.size();
  }
  resists.remove(total + who);
 }
 BTTargetedEffect::remove(combat, g, who);
}

void BTAttackEffect::displayResists(BTDisplay &d, BTCombat *combat)
{
 std::string text;
 if (BTTARGET_ALLMONSTERS == group)
 {
  text = "All monsters";
 }
 else if (BTTARGET_PARTY == group)
 {
  BTParty &party = BTGame::getGame()->getParty();
  if (BTTARGET_INDIVIDUAL == target)
   text = "The whole party";
  else
   text = party[target]->name;
 }
 else if (group >= BTTARGET_MONSTER)
 {
  BTFactory<BTMonster> &monList = BTGame::getGame()->getMonsterList();
  BTMonsterGroup *grp = combat->getMonsterGroup(group - BTTARGET_MONSTER);
  if ((BTTARGET_INDIVIDUAL == target) && (1 < grp->individual.size()))
   text = monList[grp->monsterType].getPluralName();
  else
   text = monList[grp->monsterType].getName();
 }
 text += " repelled the spell!";
 d.drawMessage(text.c_str(), BTGame::getGame()->getDelay());
}

BTCureStatusEffect::BTCureStatusEffect(int t, int x, const BTEffectSource &s, int g, int trgt, int sts)
 : BTTargetedEffect(t, x, s, g, trgt), status(sts)
{
}

void BTCureStatusEffect::serialize(ObjectSerializer *s)
{
 s->add("status", &status);
 BTTargetedEffect::serialize(s);
}

int BTCureStatusEffect::maintain(BTDisplay &d, BTCombat *combat)
{
 if (BTTARGET_PARTY == group)
 {
  BTGame *game = BTGame::getGame();
  BTParty &party = game->getParty();
  if (BTTARGET_INDIVIDUAL == target)
  {
   for (int i = 0; i < party.size(); ++i)
   {
    if (status == BTSTATUS_LEVELDRAIN)
    {
     party[i]->restoreLevel();
    }
    else if (status == BTSTATUS_AGED)
    {
     party[i]->youth();
    }
    else if (party[i]->status.isSet(status))
    {
     party[i]->status.clear(status);
    }
   }
  }
  else
  {
   if (status == BTSTATUS_LEVELDRAIN)
   {
    party[target]->restoreLevel();
   }
   else if (status == BTSTATUS_AGED)
   {
    party[target]->youth();
   }
   else if (party[target]->status.isSet(status))
   {
    party[target]->status.clear(status);
   }
  }
 }
 else if (BTTARGET_ALLMONSTERS == group)
 {
  for (int i = 0; i < BTCOMBAT_MAXENCOUNTERS; ++i)
  {
   BTMonsterGroup *grp = combat->getMonsterGroup(i);
   if (NULL == grp)
    break;
   for (int k = 0; k < grp->individual.size(); ++k)
   {
    if (status == BTSTATUS_LEVELDRAIN)
    {
     grp->individual[k].restoreLevel();
    }
    else if (status == BTSTATUS_AGED)
    {
     grp->individual[k].youth();
    }
    else if ((grp->individual[k].isAlive()) && (!grp->individual[k].status.isSet(status)))
    {
     grp->individual[k].status.clear(status);
    }
   }
  }
 }
 else if (group >= BTTARGET_MONSTER)
 {
  BTMonsterGroup *grp = combat->getMonsterGroup(group - BTTARGET_MONSTER);
  if (BTTARGET_INDIVIDUAL == target)
  {
   for (int i = 0; i < grp->individual.size(); ++i)
   {
    if (status == BTSTATUS_LEVELDRAIN)
    {
     grp->individual[i].restoreLevel();
    }
    else if (status == BTSTATUS_AGED)
    {
     grp->individual[i].youth();
    }
    else if (grp->individual[i].status.isSet(status))
    {
     grp->individual[i].status.clear(status);
    }
   }
  }
  else
  {
   if (status == BTSTATUS_LEVELDRAIN)
   {
    grp->individual[target].restoreLevel();
   }
   else if (status == BTSTATUS_AGED)
   {
    grp->individual[target].youth();
   }
   else if (grp->individual[target].status.isSet(status))
   {
    grp->individual[target].status.clear(status);
   }
  }
 }
 d.drawStats();
 return 0;
}

BTHealEffect::BTHealEffect(int t, int x, const BTEffectSource &s, int g, int trgt, const BTDice &h)
 : BTTargetedEffect(t, x, s, g, trgt), heal(h)
{
}

void BTHealEffect::serialize(ObjectSerializer *s)
{
 s->add("heal", &heal);
 BTTargetedEffect::serialize(s);
}

int BTHealEffect::maintain(BTDisplay &d, BTCombat *combat)
{
 BTGame *game = BTGame::getGame();
 BTParty &party = game->getParty();
 if (BTTARGET_PARTY == group)
 {
  if (BTTARGET_INDIVIDUAL == target)
  {
   for (int i = 0; i < party.size(); ++i)
   {
    if (party[i]->isAlive())
    {
     party[i]->giveHP(heal.roll());
    }
   }
  }
  else
  {
   if (party[target]->isAlive())
    party[target]->giveHP(heal.roll());
  }
  d.drawStats();
 }
 return 0;
}

BTSummonMonsterEffect::BTSummonMonsterEffect(int t, int x, const BTEffectSource &s, int g, int trgt)
 : BTTargetedEffect(t, x, s, g, trgt)
{
}

void BTSummonMonsterEffect::finish(BTDisplay &d, BTCombat *combat, int g /*= BTTARGET_NONE*/, int trgt /*= BTTARGET_INDIVIDUAL*/)
{
 BTGame *game = BTGame::getGame();
 BTParty &party = game->getParty();
 if (BTTARGET_PARTY == group)
 {
  std::string text = party[target]->name;
  if (party.remove(target, d))
  {
   text += " leaves your party.";
   d.drawMessage(text.c_str(), game->getDelay());
  }
 }
}

BTSummonIllusionEffect::BTSummonIllusionEffect(int t, int x, const BTEffectSource &s, int g, int trgt)
 : BTTargetedEffect(t, x, s, g, trgt)
{
}

void BTSummonIllusionEffect::finish(BTDisplay &d, BTCombat *combat, int g /*= BTTARGET_NONE*/, int trgt /*= BTTARGET_INDIVIDUAL*/)
{
 BTGame *game = BTGame::getGame();
 BTParty &party = game->getParty();
 if (BTTARGET_PARTY == group)
 {
  std::string text = "The illusionary ";
  text += party[target]->name;
  if (party.remove(target, d))
  {
   text += " disappears!";
   d.drawMessage(text.c_str(), game->getDelay());
  }
 }
}

BTDispellIllusionEffect::BTDispellIllusionEffect(int t, int x, const BTEffectSource &s, int rng, int erng, int d, int g, int trgt)
 : BTTargetedEffect(t, x, s, g, trgt), range(rng), effectiveRange(erng), distance(d)
{
}

void BTDispellIllusionEffect::serialize(ObjectSerializer *s)
{
 s->add("range", &range);
 s->add("effectiveRange", &effectiveRange);
 s->add("distance", &distance);
 BTTargetedEffect::serialize(s);
}

int BTDispellIllusionEffect::maintain(BTDisplay &d, BTCombat *combat)
{
 int killed = 0;
 BTGame *game = BTGame::getGame();
 BTFactory<BTMonster> &monList = game->getMonsterList();
 if (BTTARGET_PARTY == group)
 {
  BTParty &party = game->getParty();
  if (distance > (range * (1 + effectiveRange)))
   return 0;
  if (BTTARGET_INDIVIDUAL == target)
  {
   killed += applyToGroup(d, &party);
  }
  else
  {
   killed += apply(d, party[target]);
  }
 }
 else if (BTTARGET_ALLMONSTERS == group)
 {
  int resistOffset = 0;
  for (int i = 0; i < BTCOMBAT_MAXENCOUNTERS; ++i)
  {
   BTMonsterGroup *grp = combat->getMonsterGroup(i);
   if (NULL == grp)
    break;
   killed += applyToGroup(d, grp);
   resistOffset += grp->size();
  }
 }
 else if (group >= BTTARGET_MONSTER)
 {
  BTMonsterGroup *grp = combat->getMonsterGroup(group - BTTARGET_MONSTER);
  if (abs(grp->distance - distance) > (range * (1 + effectiveRange)))
   return 0;
  if (BTTARGET_INDIVIDUAL == target)
  {
   killed += applyToGroup(d, grp);
  }
  else
  {
   killed += apply(d, grp->at(target));
  }
 }
 if (BTTARGET_PARTY == group)
  d.drawStats();
 return killed;
}

int BTDispellIllusionEffect::applyToGroup(BTDisplay &d, BTCombatantCollection *grp)
{
 if (abs(grp->getDistance() - distance) > (range * (1 + effectiveRange)))
  return 0;
 int killed(0);
 for (int i = 0; i < grp->size(); ++i)
 {
  killed += apply(d, grp->at(i));
 }
 return killed;
}

int BTDispellIllusionEffect::apply(BTDisplay &d, BTCombatant *target)
{
 int killed(0);
 if ((target->isAlive()) && (target->isIllusion()))
 {
  BTGame *game = BTGame::getGame();
  int activeNum = 0;
  target->deactivate(activeNum);
  target->status.set(BTSTATUS_DEAD);
  killed += abs(activeNum);
  std::string text = "An illusionary ";
  text += target->getName();
  text += " disappears!";
  d.drawMessage(text.c_str(), game->getDelay());
 }
 return killed;
}

class BTActiveEffectTest : public BTEffectTest
{
 public:
  BTActiveEffectTest(int t, int g, int trgt, bool gd) : type(t), group(g), target(trgt), active(NULL), good(gd) {}

  bool test(BTBaseEffect *e);
  BTNonStackingBonusEffect *getActive() { return active; }

 private:
  int type;
  int group;
  int target;
  BTNonStackingBonusEffect *active;
  bool good;
};

bool BTActiveEffectTest::test(BTBaseEffect *e)
{
 if (e->type == type)
 {
  BTNonStackingBonusEffect *current = dynamic_cast<BTNonStackingBonusEffect *>(e);
  if ((current) && (current->active) && (group == current->group) && (target == current->target) && (current->isGood() == good))
  {
   active = current;
   return true;
  }
 }
 return false;
}

class BTBestInactiveEffectTest : public BTEffectTest
{
 public:
  BTBestInactiveEffectTest(int t, int g, int trgt, bool gd) : type(t), group(g), target(trgt), best(NULL), good(gd) {}

  bool test(BTBaseEffect *e);
  BTNonStackingBonusEffect *getBest() { return best; }

 private:
  int type;
  int group;
  int target;
  BTNonStackingBonusEffect *best;
  bool good;
};

bool BTBestInactiveEffectTest::test(BTBaseEffect *e)
{
 if (e->type == type)
 {
  BTNonStackingBonusEffect *current = dynamic_cast<BTNonStackingBonusEffect *>(e);
  if ((current) && (!current->active) && (group == current->group) && (target == current->target) && (current->isGood() == good))
  {
   if ((best == NULL) || (current->greater(best)))
    best = current;
  }
 }
 return false;
}

BTNonStackingBonusEffect::BTNonStackingBonusEffect(int t, int x, const BTEffectSource &s, int g, int trgt)
 : BTTargetedEffect(t, x, s, g, trgt), active(false)
{
}

void BTNonStackingBonusEffect::serialize(ObjectSerializer *s)
{
 s->add("active", &active);
 BTTargetedEffect::serialize(s);
}

int BTNonStackingBonusEffect::apply(BTDisplay &d, BTCombat *combat, int g /*= BTTARGET_NONE*/, int trgt /*= BTTARGET_INDIVIDUAL*/)
{
 BTGame *game = BTGame::getGame();
 if (g == BTTARGET_NONE)
 {
  g = group;
  trgt = target;
 }
 if ((game->getModule()->bonusStacking == true) || ((trgt != target) && (active == true)))
 {
  applyBonus(d, combat, g, trgt);
  active = true;
 }
 else
 {
  BTActiveEffectTest t(type, g, trgt, isGood());
  game->searchEffect(t);
  BTNonStackingBonusEffect *current = t.getActive();
  if ((current != NULL) && (greater(current)))
  {
   current->finishBonus(d, combat, g, trgt);
   current->active = false;
   current = NULL;
  }
  if (current == NULL)
  {
   applyBonus(d, combat, g, trgt);
   active = true;
  }
 }
}

void BTNonStackingBonusEffect::finish(BTDisplay &d, BTCombat *combat, int g /*= BTTARGET_NONE*/, int trgt /*= BTTARGET_INDIVIDUAL*/)
{
 BTGame *game = BTGame::getGame();
 if (g == BTTARGET_NONE)
 {
  g = group;
  trgt = target;
 }
 if ((game->getModule()->bonusStacking == true) || ((trgt != target) && (active == true)))
 {
  finishBonus(d, combat, g, trgt);
 }
 else if (active == true)
 {
  finishBonus(d, combat, g, trgt);
  BTBestInactiveEffectTest t(type, g, trgt, isGood());
  game->searchEffect(t);
  BTNonStackingBonusEffect *current = t.getBest();
  if (current)
  {
   current->applyBonus(d, combat, g, trgt);
   current->active = true;
  }
 }
}

BTArmorBonusEffect::BTArmorBonusEffect(int t, int x, const BTEffectSource &s, int g, int trgt, int b)
 : BTNonStackingBonusEffect(t, x, s, g, trgt), bonus(b)
{
}

void BTArmorBonusEffect::serialize(ObjectSerializer *s)
{
 s->add("bonus", &bonus);
 BTNonStackingBonusEffect::serialize(s);
}

int BTArmorBonusEffect::applyBonus(BTDisplay &d, BTCombat *combat, int g, int trgt)
{
 BTGame *game = BTGame::getGame();
 BTParty &party = game->getParty();
 if (BTTARGET_PARTY == g)
 {
  if (BTTARGET_INDIVIDUAL == trgt)
  {
   for (int i = 0; i < party.size(); ++i)
   {
    party[i]->ac += bonus;
   }
  }
  else
  {
   party[trgt]->ac += bonus;
  }
  d.drawStats();
 }
 else if (BTTARGET_ALLMONSTERS == g)
 {
  for (int i = 0; i < BTCOMBAT_MAXENCOUNTERS; ++i)
  {
   BTMonsterGroup *grp = combat->getMonsterGroup(i);
   if (NULL == grp)
    break;
   for (int k = 0; k < grp->individual.size(); ++k)
   {
    grp->individual[k].ac += bonus;
   }
  }
 }
 else if (g >= BTTARGET_MONSTER)
 {
  BTMonsterGroup *grp = combat->getMonsterGroup(g - BTTARGET_MONSTER);
  if (BTTARGET_INDIVIDUAL == trgt)
  {
   for (int i = 0; i < grp->individual.size(); ++i)
   {
    grp->individual[i].ac += bonus;
   }
  }
  else
  {
   grp->individual[trgt].ac += bonus;
  }
 }
 return 0;
}

bool BTArmorBonusEffect::greater(BTNonStackingBonusEffect *b)
{
 BTArmorBonusEffect *other = dynamic_cast<BTArmorBonusEffect*>(b);
 if (other == NULL)
 {
  printf("Incorrect Type\n");
  exit(0);
 }
 if (isGood())
 {
  if (bonus > other->bonus)
   return true;
  else
   return false;
 }
 else
 {
  if (bonus <= other->bonus)
   return true;
  else
   return false;
 }
}

bool BTArmorBonusEffect::isGood()
{
 if (bonus >= 0)
  return true;
 else
  return false;
}

void BTArmorBonusEffect::finishBonus(BTDisplay &d, BTCombat *combat, int g, int trgt)
{
 BTGame *game = BTGame::getGame();
 BTParty &party = game->getParty();
 if (BTTARGET_PARTY == g)
 {
  if (BTTARGET_INDIVIDUAL == trgt)
  {
   for (int i = 0; i < party.size(); ++i)
   {
    party[i]->ac -= bonus;
   }
  }
  else
  {
   party[trgt]->ac -= bonus;
  }
  d.drawStats();
 }
 else if (BTTARGET_ALLMONSTERS == g)
 {
  for (int i = 0; i < BTCOMBAT_MAXENCOUNTERS; ++i)
  {
   BTMonsterGroup *grp = combat->getMonsterGroup(i);
   if (NULL == grp)
    break;
   for (int k = 0; k < grp->individual.size(); ++k)
   {
    grp->individual[k].ac -= bonus;
   }
  }
 }
 else if (g >= BTTARGET_MONSTER)
 {
  BTMonsterGroup *grp = combat->getMonsterGroup(g - BTTARGET_MONSTER);
  if (BTTARGET_INDIVIDUAL == trgt)
  {
   for (int i = 0; i < grp->individual.size(); ++i)
   {
    grp->individual[i].ac -= bonus;
   }
  }
  else
  {
   grp->individual[trgt].ac -= bonus;
  }
 }
}

BTHitBonusEffect::BTHitBonusEffect(int t, int x, const BTEffectSource &s, int g, int trgt, int b)
 : BTNonStackingBonusEffect(t, x, s, g, trgt), bonus(b)
{
}

void BTHitBonusEffect::serialize(ObjectSerializer *s)
{
 s->add("bonus", &bonus);
 BTNonStackingBonusEffect::serialize(s);
}

int BTHitBonusEffect::applyBonus(BTDisplay &d, BTCombat *combat, int g, int trgt)
{
 BTGame *game = BTGame::getGame();
 BTParty &party = game->getParty();
 if (BTTARGET_PARTY == g)
 {
  if (BTTARGET_INDIVIDUAL == trgt)
  {
   for (int i = 0; i < party.size(); ++i)
   {
    party[i]->toHit += bonus;
   }
  }
  else
  {
   party[trgt]->toHit += bonus;
  }
  d.drawStats();
 }
 else if (BTTARGET_ALLMONSTERS == g)
 {
  for (int i = 0; i < BTCOMBAT_MAXENCOUNTERS; ++i)
  {
   BTMonsterGroup *grp = combat->getMonsterGroup(i);
   if (NULL == grp)
    break;
   for (int k = 0; k < grp->individual.size(); ++k)
   {
    grp->individual[k].toHit += bonus;
   }
  }
 }
 else if (g >= BTTARGET_MONSTER)
 {
  BTMonsterGroup *grp = combat->getMonsterGroup(g - BTTARGET_MONSTER);
  if (BTTARGET_INDIVIDUAL == trgt)
  {
   for (int i = 0; i < grp->individual.size(); ++i)
   {
    grp->individual[i].toHit += bonus;
   }
  }
  else
  {
   grp->individual[trgt].toHit += bonus;
  }
 }
 return 0;
}

bool BTHitBonusEffect::greater(BTNonStackingBonusEffect *b)
{
 BTHitBonusEffect *other = dynamic_cast<BTHitBonusEffect*>(b);
 if (other == NULL)
 {
  printf("Incorrect Type\n");
  exit(0);
 }
 if (isGood())
 {
  if (bonus > other->bonus)
   return true;
  else
   return false;
 }
 else
 {
  if (bonus <= other->bonus)
   return true;
  else
   return false;
 }
}

bool BTHitBonusEffect::isGood()
{
 if (bonus >= 0)
  return true;
 else
  return false;
}

void BTHitBonusEffect::finishBonus(BTDisplay &d, BTCombat *combat, int g, int trgt)
{
 BTGame *game = BTGame::getGame();
 BTParty &party = game->getParty();
 if (BTTARGET_PARTY == g)
 {
  if (BTTARGET_INDIVIDUAL == trgt)
  {
   for (int i = 0; i < party.size(); ++i)
   {
    party[i]->toHit -= bonus;
   }
  }
  else
  {
   party[trgt]->toHit -= bonus;
  }
  d.drawStats();
 }
 else if (BTTARGET_ALLMONSTERS == g)
 {
  for (int i = 0; i < BTCOMBAT_MAXENCOUNTERS; ++i)
  {
   BTMonsterGroup *grp = combat->getMonsterGroup(i);
   if (NULL == grp)
    break;
   for (int k = 0; k < grp->individual.size(); ++k)
   {
    grp->individual[k].toHit -= bonus;
   }
  }
 }
 else if (g >= BTTARGET_MONSTER)
 {
  BTMonsterGroup *grp = combat->getMonsterGroup(g - BTTARGET_MONSTER);
  if (BTTARGET_INDIVIDUAL == trgt)
  {
   for (int i = 0; i < grp->individual.size(); ++i)
   {
    grp->individual[i].toHit -= bonus;
   }
  }
  else
  {
   grp->individual[trgt].toHit -= bonus;
  }
 }
}

BTResurrectEffect::BTResurrectEffect(int t, int x, const BTEffectSource &s, int g, int trgt)
 : BTTargetedEffect(t, x, s, g, trgt)
{
}

int BTResurrectEffect::maintain(BTDisplay &d, BTCombat *combat)
{
 if (BTTARGET_PARTY == group)
 {
  if (BTTARGET_INDIVIDUAL == target)
  {
   BTGame *game = BTGame::getGame();
   BTParty &party = game->getParty();
   for (int i = 0; i < party.size(); ++i)
   {
    if (!party[i]->isAlive())
    {
     std::string text = party[i]->name;
     text += " rises from the dead!";
     d.drawMessage(text.c_str(), game->getDelay());
     party[i]->status.clear(BTSTATUS_DEAD);
     party[i]->hp = 1;
    }
   }
   d.drawStats();
  }
  else
  {
   // BTCS either cancels spells on death or doesn't implement this
  }
 }
}

BTDispellMagicEffect::BTDispellMagicEffect(int t, int x, const BTEffectSource &s, int rng, int erng, int d, int g, int trgt)
 : BTTargetedEffect(t, x, s, g, trgt), range(rng), effectiveRange(erng), distance(d)
{
}

void BTDispellMagicEffect::serialize(ObjectSerializer *s)
{
 s->add("range", &range);
 s->add("effectiveRange", &effectiveRange);
 s->add("distance", &distance);
 BTTargetedEffect::serialize(s);
}

int BTDispellMagicEffect::maintain(BTDisplay &d, BTCombat *combat)
{
 bool oldExpire = expire;
 BTGame *game = BTGame::getGame();
 if (BTTARGET_PARTY == group)
 {
  if (distance > (range * (1 + effectiveRange)))
   return 0;
  game->clearEffectsBySource(d, false, group, target);
 }
 else if (BTTARGET_ALLMONSTERS == group)
 {
  for (int i = 0; i < BTCOMBAT_MAXENCOUNTERS; ++i)
  {
   BTMonsterGroup *grp = combat->getMonsterGroup(i);
   if (NULL == grp)
    break;
   if (abs(grp->distance - distance) > (range * (1 + effectiveRange)))
    continue;
   game->clearEffectsBySource(d, false, i + BTTARGET_MONSTER, target);
  }
 }
 else if (group >= BTTARGET_MONSTER)
 {
  BTMonsterGroup *grp = combat->getMonsterGroup(group - BTTARGET_MONSTER);
  if (abs(grp->distance - distance) > (range * (1 + effectiveRange)))
   return 0;
  game->clearEffectsBySource(d, false, group, target);
 }
 expire = oldExpire;
 return 0;
}

BTPhaseDoorEffect::BTPhaseDoorEffect(int t, int x, const BTEffectSource &s, int mX, int mY, int f)
 : BTBaseEffect(t, x, s), mapX(mX), mapY(mY), facing(f)
{
}

void BTPhaseDoorEffect::serialize(ObjectSerializer *s)
{
 s->add("mapX", &mapX);
 s->add("mapY", &mapY);
 s->add("facing", &facing);
 BTBaseEffect::serialize(s);
}

BTRegenSkillEffect::BTRegenSkillEffect(int t, int x, const BTEffectSource &s, int g, int trgt, int sk, const BTDice& u, bool unl)
 : BTTargetedEffect(t, x, s, g, trgt), skill(sk), use(u), unlimited(unl)
{
}

void BTRegenSkillEffect::serialize(ObjectSerializer *s)
{
 s->add("skill", &skill);
 s->add("use", &use);
 s->add("unlimited", &unlimited);
 BTTargetedEffect::serialize(s);
}

int BTRegenSkillEffect::apply(BTDisplay &d, BTCombat *combat, int g /*= BTTARGET_NONE*/, int trgt /*= BTTARGET_INDIVIDUAL*/)
{
 int g2 = g;
 int trgt2 = trgt;
 if (g == BTTARGET_NONE)
 {
  g2 = group;
  trgt2 = target;
 }
 if (unlimited)
 {
  BTGame *game = BTGame::getGame();
  BTParty &party = game->getParty();
  if (BTTARGET_PARTY == g2)
  {
   if (BTTARGET_INDIVIDUAL == trgt2)
   {
    for (int i = 0; i < party.size(); ++i)
    {
     party[i]->setSkillUnlimited(skill, unlimited);
    }
   }
   else
   {
    party[trgt2]->setSkillUnlimited(skill, unlimited);
   }
  }
 }
 return BTTargetedEffect::apply(d, combat, g, trgt);
}

int BTRegenSkillEffect::maintain(BTDisplay &d, BTCombat *combat)
{
 BTGame *game = BTGame::getGame();
 BTParty &party = game->getParty();
 if (BTTARGET_PARTY == group)
 {
  if (BTTARGET_INDIVIDUAL == target)
  {
   for (int i = 0; i < party.size(); ++i)
   {
    if (party[i]->isAlive())
    {
     party[i]->giveSkillUse(skill, use.roll());
    }
   }
  }
  else
  {
   if (party[target]->isAlive())
    party[target]->giveSkillUse(skill, use.roll());
  }
  d.drawStats();
 }
 return 0;
}

void BTRegenSkillEffect::finish(BTDisplay &d, BTCombat *combat, int g /*= BTTARGET_NONE*/, int trgt /*= BTTARGET_INDIVIDUAL*/)
{
 if (g == BTTARGET_NONE)
 {
  g = group;
  trgt = target;
 }
 if (unlimited)
 {
  BTGame *game = BTGame::getGame();
  BTParty &party = game->getParty();
  if (BTTARGET_PARTY == g)
  {
   if (BTTARGET_INDIVIDUAL == trgt)
   {
    for (int i = 0; i < party.size(); ++i)
    {
     party[i]->setSkillUnlimited(skill, false);
    }
   }
   else
   {
    party[trgt]->setSkillUnlimited(skill, false);
   }
  }
 }
 BTTargetedEffect::finish(d, combat, g, trgt);
}

BTPushEffect::BTPushEffect(int t, int x, const BTEffectSource &s, int g, int trgt, int dis)
 : BTTargetedEffect(t, x, s, g, trgt), distance(dis)
{
}

void BTPushEffect::serialize(ObjectSerializer *s)
{
 s->add("distance", &distance);
 BTTargetedEffect::serialize(s);
}

int BTPushEffect::maintain(BTDisplay &d, BTCombat *combat)
{
 if (combat == NULL)
  return 0;
 if (BTTARGET_PARTY == group)
 {
  for (int i = 0; i < BTCOMBAT_MAXENCOUNTERS; ++i)
  {
   BTMonsterGroup *grp = combat->getMonsterGroup(i);
   if (NULL == grp)
    break;
   grp->push(-1 * distance);
  }
 }
 else if (BTTARGET_ALLMONSTERS == group)
 {
  for (int i = 0; i < BTCOMBAT_MAXENCOUNTERS; ++i)
  {
   BTMonsterGroup *grp = combat->getMonsterGroup(i);
   if (NULL == grp)
    break;
   grp->push(distance);
  }
 }
 else if (group >= BTTARGET_MONSTER)
 {
  BTMonsterGroup *grp = combat->getMonsterGroup(group - BTTARGET_MONSTER);
  grp->push(distance);
 }
 return 0;
}

BTAttackRateBonusEffect::BTAttackRateBonusEffect(int t, int x, const BTEffectSource &s, int g, int trgt, int b)
 : BTNonStackingBonusEffect(t, x, s, g, trgt), bonus(b)
{
}

void BTAttackRateBonusEffect::serialize(ObjectSerializer *s)
{
 s->add("bonus", &bonus);
 BTNonStackingBonusEffect::serialize(s);
}

int BTAttackRateBonusEffect::applyBonus(BTDisplay &d, BTCombat *combat, int g, int trgt)
{
 BTGame *game = BTGame::getGame();
 BTParty &party = game->getParty();
 if (BTTARGET_PARTY == g)
 {
  if (BTTARGET_INDIVIDUAL == trgt)
  {
   for (int i = 0; i < party.size(); ++i)
   {
    party[i]->rateAttacks += bonus;
   }
  }
  else
  {
   party[trgt]->rateAttacks += bonus;
  }
  d.drawStats();
 }
 else
 {
  // Doesn't work on monsters
 }
 return 0;
}

bool BTAttackRateBonusEffect::greater(BTNonStackingBonusEffect *b)
{
 BTAttackRateBonusEffect *other = dynamic_cast<BTAttackRateBonusEffect*>(b);
 if (other == NULL)
 {
  printf("Incorrect Type\n");
  exit(0);
 }
 if (isGood())
 {
  if (bonus > other->bonus)
   return true;
  else
   return false;
 }
 else
 {
  if (bonus <= other->bonus)
   return true;
  else
   return false;
 }
}

bool BTAttackRateBonusEffect::isGood()
{
 if (bonus >= 0)
  return true;
 else
  return false;
}

void BTAttackRateBonusEffect::finishBonus(BTDisplay &d, BTCombat *combat, int g, int trgt)
{
 BTGame *game = BTGame::getGame();
 BTParty &party = game->getParty();
 if (BTTARGET_PARTY == g)
 {
  if (BTTARGET_INDIVIDUAL == trgt)
  {
   for (int i = 0; i < party.size(); ++i)
   {
    party[i]->rateAttacks -= bonus;
   }
  }
  else
  {
   party[trgt]->rateAttacks -= bonus;
  }
  d.drawStats();
 }
 else
 {
  // Doesn't work on monsters
 }
}

BTRegenManaEffect::BTRegenManaEffect(int t, int x, const BTEffectSource &s, int g, int trgt, const BTDice &sp, int d)
 : BTTargetedEffect(t, x, s, g, trgt), mana(sp), delay(d)
{
}

void BTRegenManaEffect::serialize(ObjectSerializer *s)
{
 s->add("mana", &mana);
 s->add("delay", &delay);
 BTTargetedEffect::serialize(s);
}

int BTRegenManaEffect::maintain(BTDisplay &d, BTCombat *combat)
{
 BTGame *game = BTGame::getGame();
 if (delay > 0)
 {
  if ((first) || ((game->getGameTime() % delay) != 0))
   return 0;
 }
 BTParty &party = game->getParty();
 if (BTTARGET_PARTY == group)
 {
  if (BTTARGET_INDIVIDUAL == target)
  {
   for (int i = 0; i < party.size(); ++i)
   {
    if (party[i]->isAlive())
    {
     party[i]->giveSP(mana.roll());
    }
   }
  }
  else
  {
   if (party[target]->isAlive())
    party[target]->giveSP(mana.roll());
  }
  d.drawStats();
 }
 return 0;
}

BTSaveBonusEffect::BTSaveBonusEffect(int t, int x, const BTEffectSource &s, int g, int trgt, int b)
 : BTNonStackingBonusEffect(t, x, s, g, trgt), bonus(b)
{
}

void BTSaveBonusEffect::serialize(ObjectSerializer *s)
{
 s->add("bonus", &bonus);
 BTNonStackingBonusEffect::serialize(s);
}

int BTSaveBonusEffect::applyBonus(BTDisplay &d, BTCombat *combat, int g, int trgt)
{
 BTGame *game = BTGame::getGame();
 BTParty &party = game->getParty();
 if (BTTARGET_PARTY == g)
 {
  if (BTTARGET_INDIVIDUAL == trgt)
  {
   for (int i = 0; i < party.size(); ++i)
   {
    party[i]->save += bonus;
   }
  }
  else
  {
   party[trgt]->save += bonus;
  }
  d.drawStats();
 }
 else
 {
  // Doesn't work on monsters
 }
 return 0;
}

bool BTSaveBonusEffect::greater(BTNonStackingBonusEffect *b)
{
 BTSaveBonusEffect *other = dynamic_cast<BTSaveBonusEffect*>(b);
 if (other == NULL)
 {
  printf("Incorrect Type\n");
  exit(0);
 }
 if (isGood())
 {
  if (bonus > other->bonus)
   return true;
  else
   return false;
 }
 else
 {
  if (bonus <= other->bonus)
   return true;
  else
   return false;
 }
}

bool BTSaveBonusEffect::isGood()
{
 if (bonus >= 0)
  return true;
 else
  return false;
}

void BTSaveBonusEffect::finishBonus(BTDisplay &d, BTCombat *combat, int g, int trgt)
{
 BTGame *game = BTGame::getGame();
 BTParty &party = game->getParty();
 if (BTTARGET_PARTY == g)
 {
  if (BTTARGET_INDIVIDUAL == trgt)
  {
   for (int i = 0; i < party.size(); ++i)
   {
    party[i]->save -= bonus;
   }
  }
  else
  {
   party[trgt]->save -= bonus;
  }
  d.drawStats();
 }
 else
 {
  // Doesn't work on monsters
 }
}

BTScrySightEffect::BTScrySightEffect(int t, int x, const BTEffectSource &s)
 : BTBaseEffect(t, x, s)
{
}

int BTScrySightEffect::maintain(BTDisplay &d, BTCombat *combat)
{
 d.drawView();
 d.drawMap(true);
}

BTSpellBindEffect::BTSpellBindEffect(int t, int x, const BTEffectSource &s, int g, int trgt)
 : BTResistedEffect(t, x, s, g, trgt)
{
}

int BTSpellBindEffect::apply(BTDisplay &d, BTCombat *combat, int g /*= BTTARGET_NONE*/, int trgt /*= BTTARGET_INDIVIDUAL*/)
{
 if (!targetsMonsters())
  return 0;
 if (target == BTTARGET_ALLMONSTERS)
  return 0;
 if (g == BTTARGET_NONE)
 {
  g = group;
  trgt = target;
 }
 BTGame *game = BTGame::getGame();
 BTParty &party = game->getParty();
 BTMonsterGroup *grp = combat->getMonsterGroup(g - BTTARGET_MONSTER);
 BTFactory<BTMonster> &monsterList = game->getMonsterList();
 if (checkResists(combat, g, trgt))
 {
  std::string text = monsterList[grp->monsterType].getName();
  text += " resists!";
  d.drawMessage(text.c_str(), game->getDelay());
  throw BTAllResistException();
 }
 else
 {
  if (trgt == BTTARGET_INDIVIDUAL)
  {
  }
  else
  {
   if (party.size() >= BT_PARTYSIZE)
   {
    std::string text = "No room in your party. ";
    text += monsterList[grp->monsterType].getName();
    text += " cannot join!";
    d.drawMessage(text.c_str(), game->getDelay());
   }
   else
   {
    BTPc *pc = new BTPc(grp->monsterType, BTJOB_MONSTER, grp->at(trgt));
    party.add(d, pc);
    d.drawStats();
    grp->at(trgt)->status.set(BTSTATUS_DEAD);
    return 1;
   }
  }
 }
 return 0;
}

void BTSpellBindEffect::finish(BTDisplay &d, BTCombat *combat, int g /*= BTTARGET_NONE*/, int trgt /*= BTTARGET_INDIVIDUAL*/)
{
}

BTLightEffect::BTLightEffect(int t, int x, const BTEffectSource &s, int g, int trgt, int illum)
 : BTTargetedEffect(t, x, s, g, trgt), illumination(illum)
{
}

void BTLightEffect::serialize(ObjectSerializer *s)
{
 s->add("illumination", &illumination);
 BTTargetedEffect::serialize(s);
}

BTTeleportEffect::BTTeleportEffect(int t, int x, const BTEffectSource &s, int mX, int mY, const std::string &mFile)
 : BTBaseEffect(t, x, s), mapX(mX), mapY(mY), mapFile(mFile)
{
}

void BTTeleportEffect::finish(BTDisplay &d, BTCombat *combat, int g /*= BTTARGET_NONE*/, int trgt /*= BTTARGET_INDIVIDUAL*/)
{
 BTGame *game = BTGame::getGame();
 game->teleport(d, mapFile, mapX, mapY, game->getFacing());
 game->setRunSpecial();
}

void BTTeleportEffect::serialize(ObjectSerializer *s)
{
 BTBaseEffect::serialize(s);
 s->add("mapX", &mapX);
 s->add("mapY", &mapY);
 s->add("mapFile", &mapFile);
}

BTDamageBonusEffect::BTDamageBonusEffect(int t, int x, const BTEffectSource &s, int g, int trgt, const BTDice &d, bool melee)
 : BTNonStackingBonusEffect(t, x, s, g, trgt), bonus(d, melee)
{
}

void BTDamageBonusEffect::serialize(ObjectSerializer *s)
{
 s->add("bonus", &bonus);
 BTNonStackingBonusEffect::serialize(s);
}

int BTDamageBonusEffect::applyBonus(BTDisplay &d, BTCombat *combat, int g, int trgt)
{
 BTGame *game = BTGame::getGame();
 BTParty &party = game->getParty();
 if (BTTARGET_PARTY == g)
 {
  if (BTTARGET_INDIVIDUAL == trgt)
  {
   for (int i = 0; i < party.size(); ++i)
   {
    party[i]->dmgBonus.push_back(new BTDamageBonus(bonus));
   }
  }
  else
  {
   party[trgt]->dmgBonus.push_back(new BTDamageBonus(bonus));
  }
  d.drawStats();
 }
 else if (BTTARGET_ALLMONSTERS == g)
 {
  for (int i = 0; i < BTCOMBAT_MAXENCOUNTERS; ++i)
  {
   BTMonsterGroup *grp = combat->getMonsterGroup(i);
   if (NULL == grp)
    break;
   for (int k = 0; k < grp->individual.size(); ++k)
   {
    grp->individual[k].dmgBonus.push_back(new BTDamageBonus(bonus));
   }
  }
 }
 else if (g >= BTTARGET_MONSTER)
 {
  BTMonsterGroup *grp = combat->getMonsterGroup(g - BTTARGET_MONSTER);
  if (BTTARGET_INDIVIDUAL == trgt)
  {
   for (int i = 0; i < grp->individual.size(); ++i)
   {
    grp->individual[i].dmgBonus.push_back(new BTDamageBonus(bonus));
   }
  }
  else
  {
   grp->individual[trgt].dmgBonus.push_back(new BTDamageBonus(bonus));
  }
 }
 return 0;
}

bool BTDamageBonusEffect::greater(BTNonStackingBonusEffect *b)
{
 BTDamageBonusEffect *other = dynamic_cast<BTDamageBonusEffect*>(b);
 if (other == NULL)
 {
  printf("Incorrect Type\n");
  exit(0);
 }
 if (isGood())
 {
  if (bonus.getMax() > other->bonus.getMax())
   return true;
  else
   return false;
 }
 else
 {
  if (bonus.getMax() <= other->bonus.getMax())
   return true;
  else
   return false;
 }
}

bool BTDamageBonusEffect::isGood()
{
 if (bonus.getMax() >= 0)
  return true;
 else
  return false;
}

void BTDamageBonusEffect::finishBonus(BTDisplay &d, BTCombat *combat, int g, int trgt)
{
 BTGame *game = BTGame::getGame();
 BTParty &party = game->getParty();
 if (BTTARGET_PARTY == g)
 {
  if (BTTARGET_INDIVIDUAL == trgt)
  {
   for (int i = 0; i < party.size(); ++i)
   {
    for (int dmgNum = 0; dmgNum < party[i]->dmgBonus.size(); dmgNum++)
    {
     if ((*party[i]->dmgBonus[dmgNum]) == bonus)
     {
      party[i]->dmgBonus.erase(dmgNum);
      break;
     }
    }
   }
  }
  else
  {
   for (int dmgNum = 0; dmgNum < party[trgt]->dmgBonus.size(); dmgNum++)
   {
    if ((*party[trgt]->dmgBonus[dmgNum]) == bonus)
    {
     party[trgt]->dmgBonus.erase(dmgNum);
     break;
    }
   }
  }
  d.drawStats();
 }
 else if (BTTARGET_ALLMONSTERS == g)
 {
  for (int i = 0; i < BTCOMBAT_MAXENCOUNTERS; ++i)
  {
   BTMonsterGroup *grp = combat->getMonsterGroup(i);
   if (NULL == grp)
    break;
   for (int k = 0; k < grp->individual.size(); ++k)
   {
    for (int dmgNum = 0; dmgNum < grp->individual[k].dmgBonus.size(); dmgNum++)
    {
     if ((*grp->individual[k].dmgBonus[dmgNum]) == bonus)
     {
      grp->individual[k].dmgBonus.erase(dmgNum);
      break;
     }
    }
   }
  }
 }
 else if (g >= BTTARGET_MONSTER)
 {
  BTMonsterGroup *grp = combat->getMonsterGroup(g - BTTARGET_MONSTER);
  if (BTTARGET_INDIVIDUAL == trgt)
  {
   for (int i = 0; i < grp->individual.size(); ++i)
   {
    for (int dmgNum = 0; dmgNum < grp->individual[i].dmgBonus.size(); dmgNum++)
    {
     if ((*grp->individual[i].dmgBonus[dmgNum]) == bonus)
     {
      grp->individual[i].dmgBonus.erase(dmgNum);
      break;
     }
    }
   }
  }
  else
  {
   for (int dmgNum = 0; dmgNum < grp->individual[trgt].dmgBonus.size(); dmgNum++)
   {
    if ((*grp->individual[trgt].dmgBonus[dmgNum]) == bonus)
    {
     grp->individual[trgt].dmgBonus.erase(dmgNum);
     break;
    }
   }
  }
 }
}

BTDetectEffect::BTDetectEffect(int t, int x, const BTEffectSource &s, int r, const BitField &f)
 : BTBaseEffect(t, x, s), range(r), flags(f)
{
}

int BTDetectEffect::maintain(BTDisplay &d, BTCombat *combat)
{
 // If in combat do not report anything.
 if (!combat)
 {
  BTGame *game = BTGame::getGame();
  BTSpecialFlagList &flagList = game->getSpecialFlagList();
  BitField found;
  int x = game->getX();
  int y = game->getY();
  int dir = game->getFacing();
  for (int i = 0; i < 3; ++i)
  {
   x += Psuedo3D::changeXY[dir][0];
   y += Psuedo3D::changeXY[dir][1];
   game->rationalize(x, y);
   IShort s = game->getMap()->getSquare(y, x).getSpecial();
   if (s != BTSPECIAL_NONE)
   {
    BTSpecial *sp = game->getMap()->getSpecial(s);
    found |= flags & sp->getFlag();
   }
  }
  int max = flagList.size();
  for (int i = 0; i < max; ++i)
  {
   if (found.isSet(i))
   {
    d.drawText(flagList[i]->detect.c_str());
   }
  }
 }
}

void BTDetectEffect::serialize(ObjectSerializer* s)
{
 BTCore *game = BTCore::getCore();
 BTSpecialFlagList &flagList = game->getSpecialFlagList();
 BTBaseEffect::serialize(s);
 s->add("range", &range);
 s->add("flag", &flags, &flagList);
}

BTLocationEffect::BTLocationEffect(int t, int x, const BTEffectSource &s)
 : BTBaseEffect(t, x, s)
{
}

int BTLocationEffect::maintain(BTDisplay &d, BTCombat *combat)
{
 // If in combat do not report anything.
 if (!combat)
 {
  BTGame *game = BTGame::getGame();
  std::string text = "You face ";
  text += directions[game->getFacing()];
  BTLevel *level = game->getLevel();
  if (level)
  {
   text += ", and are ";
   char s[50];
   snprintf(s, 50, "%d", level->level(game->getMap()->getFilename()));
   text += s;
   text += " levels below, ";
   snprintf(s, 50, "%d", game->getYSize() - game->getY());
   text += s;
   text += " squares north, ";
   snprintf(s, 50, "%d", game->getX());
   text += s;
   text += " squares east of the entry stairs.";
  }
  else
  {
   text += " and are in ";
   text += game->getMap()->getName();
   text += ".";
  }
  d.drawText(text.c_str());
 }
}
